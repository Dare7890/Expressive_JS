Тайная жизнь объектов 

Инкапсуляция - разделение интерфейса от реализации.
Методы - свойства, которые хранят функцию.
Для методов можно вызвать call, где в качестве первого аргумента передается this.

Прототипы - родители.
Если мы обращаемся к свойству объекта, которого у него нет, то он будет искать его у прототипа и т.д.
Базовый прототип - Object.prototype.
Object.create(объект) - создание объекта, где объект является прототипом нового объекта.

Если есть конструктор, то для добавления свойств прототипу используется конструкция:
Конструктор.prototype.свойство = ...
То есть прототип связан с конструктором при помощи ключевого слова prototype.

При создании объекта при помощи конструктора сам объект будет ссылаться на прототип с названием конструктора, в котором и будет содержаться сам конструктор. Это позволяет реализовывать наследование.

Значение свойства prototype - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов.

Вместо прототипов появился синтаксический сахар - extends(используется при наследовании).
Для обращения к базовому классу - super();
Для создания конструктора - constructor
Методы также хранятся в прототипе конструктора.
Свойства хранятся у самого объекта.

Rabbit.prototype.teeth = "маленькие"; 
console.log(killerRabbit.teeth); 
//-> маленькие 
killerRabbit.teeth = "длинные, острые и кровавые"; 
console.log(killerRabbit.teeth); 
//-> длинные, острые и кровавые 
console.log(ЫackRabbit.teeth); 
//-> маленькие 
console.log(Rabbit.prototype.teeth); 
//-> маленькие

Словарь.
let map = new Map();
Свойства get, has и set.
В объектах в качестве ключа используются строки, а в словаре значения любого типа. Если 2 одинаковых значения разных типов, то они сохранятся в разных местах.

Set - аналогично HashSet, коллекция, которая хранит значения, повторяющиеся только 1 раз.

Для перебора должен быть реализован итератор, который содержит методы next, объект со свойством value и done.

Свойства.
get название(){
    return...
}

set название(value){
    this...
}

подкласс instanceof базовый класс- является ли подкласс потомком базового класса.

Определив геттеры и сеттеры, вы создаете методы, которые будут незаметно 
вызываться при каждом обращении к объекту. Статические методы - это 
методы, хранящиеся в конструкторе класса, а не в его прототипе. 

Ключевое слово this.
При использовании его в глобальном контексте оно указывает на объект window.

function myFunction() {
  console.log(this);
}

// Вызовем функцию
myFunction(); 

// функция выводит тот же объект Window! 
// Window { postMessage: ƒ, 
// blur: ƒ, 
// focus: ƒ, 
// close: ƒ, 
// frames: Window, …}

При использовании его в функциях в глобальном контексте не в строгом режиме this == window. (В строгом режиме вернет undefied).

При использовании его внутри объекта оно указывает на сам объект.

var dog = {
  name: 'Chester',
  breed: 'beagle',
  intro: function(){
    console.log(this);
  }
};

dog.intro();

// в консоль выводится представление объекта dog со всеми его свойствами и методами
// {name: "Chester", breed: "beagle", intro: ƒ}
//    breed:"beagle"
//    intro:ƒ ()
//    name:"Chester"
//    __proto__:Object

Во вложенных объектах this указывает на тот объект, в методе которого оно используется.

Для стрелочных функций this относится к глобальному контексту(window, если вне других объектов).

Если мы создаем функцию вне объекта и затем присваем эту функцию свойству объекта.

var dog = {
  breed: 'Beagles',
  lovesToChase: 'rabbits'
};

function chase() {
  console.log(this.breed + ' loves chasing ' + this.lovesToChase + '.'); 
}

dog.foo = chase;
dog.foo(); // в консоль попадёт Beagles loves chasing rabbits.

chase(); //так эту функцию лучше не вызывать

Тут вместо this подставляется объект dog.

bind - связывает фукцию с объектом, заменяя ключевое слово this на объект. При этом функция не вызывается, а возвращается новая функция, которую в последствии можно вызвать.

call - вызывает функцию с подменой контекста.(аргументы только по одному передаются)
apply - вызов функции с переменным количеством аргументов и с подменой контекста.(то есть может принимать аргументы в виде массива)

Статические методы присваиваются не прототипу, а самому объекту-классу.