Глава 11. Асинхронность.
В асинхронных функциях используюся функции обратного вызова(колбеки). Когда асинхронная функция прекращает выполнения, то запускается выполнение колбека, которому будет передан результат выполнения асинхронной функции.

Промис ~ Task - асинхронное действие, при завершении которого извлекается полученное значение.
let result = Promise.resolve() - создание.
result.then(value => console.log(`Получено ${value}`)) - результат промиса без исключений.
То есть то, что в then - это колбек, который вызовется при выполнении промиса.
then также возвращает промис.
Для создания промиса, то есть функции, которая будет выполняться асинхронно, используется конструктор New Promise(resolve => ...), где resolve - функция для асинхронного выполнения.

Promise.reject - функция, которая создает отклоненный промис. Также отклоненный промис создается, когда в промисе создается исключительная ситуация. Тогда для его обработки срабатывает колбек не из метода then, а из метода catch.

const prom = new Promise(function(resolve, reject){
... (асинхронный код);
})

resolve вызывается, когда асинхронная операция закончена и закончена успешно. Для передачи результатов можно в resolve передавать данные, которые получены в результате асинхронной операции.

Преимущество промисов перед колбеками - всего 1 уровень вложенности благодаря тому, что можно возвращать из обработчиков значения при помощи return и писать для новых промисов новые обработчики.
p.then(data => {
return new Promise(resolve, reject) => {...})
}.then(retrievedData => {...})

Генераторы.
Создается при помощи function*. Возвращает значение при помощи yield. Позволяет возвращает значения по 1.

Event loop.
Интерпретатор закидывает функцию в стек, выполняет ее, затем переходит к следующей строчке. Это работает для макрокоманд.
При достижении асинхронной функции интерпретатор закидывает всю функцию в стек. Затем event loop ждет, пока выполнется макрозадача. После этого микрозадача (колбек, который должен выполниться после асинхронной задачи) закидывается в специальную очередь. Когда необходимо вызвать колбек, то микрозадача перебрасывается из очереди в стек и выполняется. Это позволяет не блокировать основной поток.
Микрозадача перебрасывается из очереди в стек и выполняется только после того, как выполнятся все макрозадачи в функции.

Основные компоненты.
Call stack - хранит функции, которые выполняются по одной.
Web apis - выполняет асинхронные функции.
Callback queue - хранит колбеки и при необходимости перекидывает их в call stack.